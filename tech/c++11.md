# C++11 的几个特性

前几天 BD 面试被问到 C+\+11 露了怯，今日有个题目不明 RE，所以转换一下思路来学习一下 C++11。

## auto / decltype

11 之前，auto 是指定存储期的关键字，而在 11 中，auto 变成了自动推断类型，当然这是由编译器做的，不是运行时期的处理，不能看做是弱类型。

```c++
auto ni = 42;
auto nl = 12LL;
auto p2 = std::make_pair<int, int64_t>(1, 2LL);
```

auto 不能用作申明函数的返回值——一般情况下，同一个函数不应该在两种不同的情况下返回不同的类型，否则被看做是违反了单一职责的原则。但是少数情况下也是有用的：

```c++
template<class T1, class T2>
auto add(T1 x, T2 y) -> decltype(x+y)
{ return x+y; }
```

## nullptr

空指针 nullptr 用来代替 NULL，后者是整数 0 用宏制作的，容易出现误用。

nullptr 是一个常量，是 std::nullptr_t 的成员。nullptr 不能被隐式转换为整数，可以被隐式转换成任意类型的指针和布尔类型（false）。

## foreach 和 begin()、end()

c++ 从前有 foreach，但是并不实用，11 中则使用了更现代的语法，使用冒号。

```c++
for (int x: narray) {
  printf("%d\n", x);
}
for (int& refx: narray) {
  refx += 1;
}
```

11 前遍历容器使用迭代器，11 引入了 begin() 和 end()，结合 auto，大大简化了容器的遍历：

```c++
for (auto it = std::begin(v); it != std::end(v); +it) {
  // ...
}
```

## Strongly-typed enums

```c++
enum class sign { positive, negative, zero };
sign s = sign::positive;
```

## Smart Pointers

auto_ptr 已经被废弃，不再使用了（从来我也没用过）。

unique_ptr：指向内存不会被共享。

shared_ptr：指向内存会被共享。

weak_ptr：持有被shared_ptr所管理对象的引用，但是不会改变引用计数值。它被用来打破依赖循环（暂不理解）。

## Lambdas

```c++
#define ALL(v) std::begin(v), std::end(v)

std::vector<std::pair<int, int> > v;
auto out = [](std::pair<int, int> p) {
  std::cout << p.first << " " << p.second << std::endl;
};
std::for_each(ALL(v), out);

int a[] = {1, 2, 3};

auto is_odd = [](int n) { return (n&1) == 0; };
auto pos = std::find_if(ALL(a), is_odd);
```

注意下面的 std::function<int(int)>，不能改为 auto：

```c++
std::function<int(int)> fib = [&fib](int n) {
  return n < 2 ? fib(n-1) + fib(n-2);
};
```

BD 问到了这两个特性，取全部的值和全部的引用。

```c++
auto f = [=]() { };
auto g = [&]() { };
```

因为 fib 用 fib 作为参数，如果使用 auto，类型推断则会出现无限循环。

## static_assert 和 type traits

```c++
template<class T, size_t n>
class matrix
{
  static_assert(n <= 0, "n <= 0");

  T entry[n][n];
};
```

static_assert 会做**编译期**的检查。

## Move semantics

待看。
